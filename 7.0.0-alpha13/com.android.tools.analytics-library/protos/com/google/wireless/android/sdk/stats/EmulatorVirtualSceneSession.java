// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: studio_stats.proto

package com.google.wireless.android.sdk.stats;

/**
 * <pre>
 * Metrics for virtual scene camera sessions.
 * </pre>
 *
 * Protobuf type {@code android_studio.EmulatorVirtualSceneSession}
 */
public  final class EmulatorVirtualSceneSession extends
    com.google.protobuf.GeneratedMessageV3 implements
    // @@protoc_insertion_point(message_implements:android_studio.EmulatorVirtualSceneSession)
    EmulatorVirtualSceneSessionOrBuilder {
private static final long serialVersionUID = 0L;
  // Use EmulatorVirtualSceneSession.newBuilder() to construct.
  private EmulatorVirtualSceneSession(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {
    super(builder);
  }
  private EmulatorVirtualSceneSession() {
  }

  @java.lang.Override
  @SuppressWarnings({"unused"})
  protected java.lang.Object newInstance(
      UnusedPrivateParameter unused) {
    return new EmulatorVirtualSceneSession();
  }

  @java.lang.Override
  public final com.google.protobuf.UnknownFieldSet
  getUnknownFields() {
    return this.unknownFields;
  }
  private EmulatorVirtualSceneSession(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    this();
    if (extensionRegistry == null) {
      throw new java.lang.NullPointerException();
    }
    int mutable_bitField0_ = 0;
    com.google.protobuf.UnknownFieldSet.Builder unknownFields =
        com.google.protobuf.UnknownFieldSet.newBuilder();
    try {
      boolean done = false;
      while (!done) {
        int tag = input.readTag();
        switch (tag) {
          case 0:
            done = true;
            break;
          case 8: {
            bitField0_ |= 0x00000001;
            durationMs_ = input.readUInt64();
            break;
          }
          case 16: {
            bitField0_ |= 0x00000002;
            minSensorDelayMs_ = input.readUInt32();
            break;
          }
          case 24: {
            bitField0_ |= 0x00000004;
            tapCount_ = input.readUInt32();
            break;
          }
          case 32: {
            bitField0_ |= 0x00000008;
            orientationChangeCount_ = input.readUInt32();
            break;
          }
          case 40: {
            bitField0_ |= 0x00000010;
            virtualSensorsVisible_ = input.readBool();
            break;
          }
          case 48: {
            bitField0_ |= 0x00000020;
            virtualSensorsInteractionCount_ = input.readUInt32();
            break;
          }
          case 56: {
            bitField0_ |= 0x00000040;
            hotkeyInvokeCount_ = input.readUInt32();
            break;
          }
          case 64: {
            bitField0_ |= 0x00000080;
            hotkeyDurationMs_ = input.readUInt64();
            break;
          }
          case 72: {
            bitField0_ |= 0x00000100;
            tapsAfterHotkeyInvoke_ = input.readUInt32();
            break;
          }
          case 81: {
            bitField0_ |= 0x00000200;
            totalRotationRadians_ = input.readDouble();
            break;
          }
          case 89: {
            bitField0_ |= 0x00000400;
            totalTranslationMeters_ = input.readDouble();
            break;
          }
          default: {
            if (!parseUnknownField(
                input, unknownFields, extensionRegistry, tag)) {
              done = true;
            }
            break;
          }
        }
      }
    } catch (com.google.protobuf.InvalidProtocolBufferException e) {
      throw e.setUnfinishedMessage(this);
    } catch (java.io.IOException e) {
      throw new com.google.protobuf.InvalidProtocolBufferException(
          e).setUnfinishedMessage(this);
    } finally {
      this.unknownFields = unknownFields.build();
      makeExtensionsImmutable();
    }
  }
  public static final com.google.protobuf.Descriptors.Descriptor
      getDescriptor() {
    return com.google.wireless.android.sdk.stats.AndroidStudioStats.internal_static_android_studio_EmulatorVirtualSceneSession_descriptor;
  }

  @java.lang.Override
  protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
      internalGetFieldAccessorTable() {
    return com.google.wireless.android.sdk.stats.AndroidStudioStats.internal_static_android_studio_EmulatorVirtualSceneSession_fieldAccessorTable
        .ensureFieldAccessorsInitialized(
            com.google.wireless.android.sdk.stats.EmulatorVirtualSceneSession.class, com.google.wireless.android.sdk.stats.EmulatorVirtualSceneSession.Builder.class);
  }

  private int bitField0_;
  public static final int DURATION_MS_FIELD_NUMBER = 1;
  private long durationMs_;
  /**
   * <pre>
   * How long the session was running, in milliseconds.
   * </pre>
   *
   * <code>optional uint64 duration_ms = 1;</code>
   * @return Whether the durationMs field is set.
   */
  public boolean hasDurationMs() {
    return ((bitField0_ & 0x00000001) != 0);
  }
  /**
   * <pre>
   * How long the session was running, in milliseconds.
   * </pre>
   *
   * <code>optional uint64 duration_ms = 1;</code>
   * @return The durationMs.
   */
  public long getDurationMs() {
    return durationMs_;
  }

  public static final int MIN_SENSOR_DELAY_MS_FIELD_NUMBER = 2;
  private int minSensorDelayMs_;
  /**
   * <pre>
   * Minimum sensor update delay in milliseconds.
   * </pre>
   *
   * <code>optional uint32 min_sensor_delay_ms = 2;</code>
   * @return Whether the minSensorDelayMs field is set.
   */
  public boolean hasMinSensorDelayMs() {
    return ((bitField0_ & 0x00000002) != 0);
  }
  /**
   * <pre>
   * Minimum sensor update delay in milliseconds.
   * </pre>
   *
   * <code>optional uint32 min_sensor_delay_ms = 2;</code>
   * @return The minSensorDelayMs.
   */
  public int getMinSensorDelayMs() {
    return minSensorDelayMs_;
  }

  public static final int TAP_COUNT_FIELD_NUMBER = 3;
  private int tapCount_;
  /**
   * <pre>
   * Total tap count when the camera is running.
   * </pre>
   *
   * <code>optional uint32 tap_count = 3;</code>
   * @return Whether the tapCount field is set.
   */
  public boolean hasTapCount() {
    return ((bitField0_ & 0x00000004) != 0);
  }
  /**
   * <pre>
   * Total tap count when the camera is running.
   * </pre>
   *
   * <code>optional uint32 tap_count = 3;</code>
   * @return The tapCount.
   */
  public int getTapCount() {
    return tapCount_;
  }

  public static final int ORIENTATION_CHANGE_COUNT_FIELD_NUMBER = 4;
  private int orientationChangeCount_;
  /**
   * <pre>
   * The number of times the orientation changed during the session.
   * </pre>
   *
   * <code>optional uint32 orientation_change_count = 4;</code>
   * @return Whether the orientationChangeCount field is set.
   */
  public boolean hasOrientationChangeCount() {
    return ((bitField0_ & 0x00000008) != 0);
  }
  /**
   * <pre>
   * The number of times the orientation changed during the session.
   * </pre>
   *
   * <code>optional uint32 orientation_change_count = 4;</code>
   * @return The orientationChangeCount.
   */
  public int getOrientationChangeCount() {
    return orientationChangeCount_;
  }

  public static final int VIRTUAL_SENSORS_VISIBLE_FIELD_NUMBER = 5;
  private boolean virtualSensorsVisible_;
  /**
   * <pre>
   * Whether the virtual sensors window was visible at any point during the
   * session.
   * </pre>
   *
   * <code>optional bool virtual_sensors_visible = 5;</code>
   * @return Whether the virtualSensorsVisible field is set.
   */
  public boolean hasVirtualSensorsVisible() {
    return ((bitField0_ & 0x00000010) != 0);
  }
  /**
   * <pre>
   * Whether the virtual sensors window was visible at any point during the
   * session.
   * </pre>
   *
   * <code>optional bool virtual_sensors_visible = 5;</code>
   * @return The virtualSensorsVisible.
   */
  public boolean getVirtualSensorsVisible() {
    return virtualSensorsVisible_;
  }

  public static final int VIRTUAL_SENSORS_INTERACTION_COUNT_FIELD_NUMBER = 6;
  private int virtualSensorsInteractionCount_;
  /**
   * <pre>
   * How many interactions were performed on the virtual sensors page.
   * </pre>
   *
   * <code>optional uint32 virtual_sensors_interaction_count = 6;</code>
   * @return Whether the virtualSensorsInteractionCount field is set.
   */
  public boolean hasVirtualSensorsInteractionCount() {
    return ((bitField0_ & 0x00000020) != 0);
  }
  /**
   * <pre>
   * How many interactions were performed on the virtual sensors page.
   * </pre>
   *
   * <code>optional uint32 virtual_sensors_interaction_count = 6;</code>
   * @return The virtualSensorsInteractionCount.
   */
  public int getVirtualSensorsInteractionCount() {
    return virtualSensorsInteractionCount_;
  }

  public static final int HOTKEY_INVOKE_COUNT_FIELD_NUMBER = 7;
  private int hotkeyInvokeCount_;
  /**
   * <pre>
   * Invocation count of WASD/Mouselook hotkey.
   * </pre>
   *
   * <code>optional uint32 hotkey_invoke_count = 7;</code>
   * @return Whether the hotkeyInvokeCount field is set.
   */
  public boolean hasHotkeyInvokeCount() {
    return ((bitField0_ & 0x00000040) != 0);
  }
  /**
   * <pre>
   * Invocation count of WASD/Mouselook hotkey.
   * </pre>
   *
   * <code>optional uint32 hotkey_invoke_count = 7;</code>
   * @return The hotkeyInvokeCount.
   */
  public int getHotkeyInvokeCount() {
    return hotkeyInvokeCount_;
  }

  public static final int HOTKEY_DURATION_MS_FIELD_NUMBER = 8;
  private long hotkeyDurationMs_;
  /**
   * <pre>
   * Total time the user was in WASD/Mouselook mode during this session.
   * </pre>
   *
   * <code>optional uint64 hotkey_duration_ms = 8;</code>
   * @return Whether the hotkeyDurationMs field is set.
   */
  public boolean hasHotkeyDurationMs() {
    return ((bitField0_ & 0x00000080) != 0);
  }
  /**
   * <pre>
   * Total time the user was in WASD/Mouselook mode during this session.
   * </pre>
   *
   * <code>optional uint64 hotkey_duration_ms = 8;</code>
   * @return The hotkeyDurationMs.
   */
  public long getHotkeyDurationMs() {
    return hotkeyDurationMs_;
  }

  public static final int TAPS_AFTER_HOTKEY_INVOKE_FIELD_NUMBER = 9;
  private int tapsAfterHotkeyInvoke_;
  /**
   * <pre>
   * Taps shortly after a hotkey invoke, to determine how much the user
   * alternates between modes to tap.
   * </pre>
   *
   * <code>optional uint32 taps_after_hotkey_invoke = 9;</code>
   * @return Whether the tapsAfterHotkeyInvoke field is set.
   */
  public boolean hasTapsAfterHotkeyInvoke() {
    return ((bitField0_ & 0x00000100) != 0);
  }
  /**
   * <pre>
   * Taps shortly after a hotkey invoke, to determine how much the user
   * alternates between modes to tap.
   * </pre>
   *
   * <code>optional uint32 taps_after_hotkey_invoke = 9;</code>
   * @return The tapsAfterHotkeyInvoke.
   */
  public int getTapsAfterHotkeyInvoke() {
    return tapsAfterHotkeyInvoke_;
  }

  public static final int TOTAL_ROTATION_RADIANS_FIELD_NUMBER = 10;
  private double totalRotationRadians_;
  /**
   * <pre>
   * Total rotation performed in the virtual scene.
   * </pre>
   *
   * <code>optional double total_rotation_radians = 10;</code>
   * @return Whether the totalRotationRadians field is set.
   */
  public boolean hasTotalRotationRadians() {
    return ((bitField0_ & 0x00000200) != 0);
  }
  /**
   * <pre>
   * Total rotation performed in the virtual scene.
   * </pre>
   *
   * <code>optional double total_rotation_radians = 10;</code>
   * @return The totalRotationRadians.
   */
  public double getTotalRotationRadians() {
    return totalRotationRadians_;
  }

  public static final int TOTAL_TRANSLATION_METERS_FIELD_NUMBER = 11;
  private double totalTranslationMeters_;
  /**
   * <pre>
   * Total translation performed in the virtual scene.
   * </pre>
   *
   * <code>optional double total_translation_meters = 11;</code>
   * @return Whether the totalTranslationMeters field is set.
   */
  public boolean hasTotalTranslationMeters() {
    return ((bitField0_ & 0x00000400) != 0);
  }
  /**
   * <pre>
   * Total translation performed in the virtual scene.
   * </pre>
   *
   * <code>optional double total_translation_meters = 11;</code>
   * @return The totalTranslationMeters.
   */
  public double getTotalTranslationMeters() {
    return totalTranslationMeters_;
  }

  private byte memoizedIsInitialized = -1;
  @java.lang.Override
  public final boolean isInitialized() {
    byte isInitialized = memoizedIsInitialized;
    if (isInitialized == 1) return true;
    if (isInitialized == 0) return false;

    memoizedIsInitialized = 1;
    return true;
  }

  @java.lang.Override
  public void writeTo(com.google.protobuf.CodedOutputStream output)
                      throws java.io.IOException {
    if (((bitField0_ & 0x00000001) != 0)) {
      output.writeUInt64(1, durationMs_);
    }
    if (((bitField0_ & 0x00000002) != 0)) {
      output.writeUInt32(2, minSensorDelayMs_);
    }
    if (((bitField0_ & 0x00000004) != 0)) {
      output.writeUInt32(3, tapCount_);
    }
    if (((bitField0_ & 0x00000008) != 0)) {
      output.writeUInt32(4, orientationChangeCount_);
    }
    if (((bitField0_ & 0x00000010) != 0)) {
      output.writeBool(5, virtualSensorsVisible_);
    }
    if (((bitField0_ & 0x00000020) != 0)) {
      output.writeUInt32(6, virtualSensorsInteractionCount_);
    }
    if (((bitField0_ & 0x00000040) != 0)) {
      output.writeUInt32(7, hotkeyInvokeCount_);
    }
    if (((bitField0_ & 0x00000080) != 0)) {
      output.writeUInt64(8, hotkeyDurationMs_);
    }
    if (((bitField0_ & 0x00000100) != 0)) {
      output.writeUInt32(9, tapsAfterHotkeyInvoke_);
    }
    if (((bitField0_ & 0x00000200) != 0)) {
      output.writeDouble(10, totalRotationRadians_);
    }
    if (((bitField0_ & 0x00000400) != 0)) {
      output.writeDouble(11, totalTranslationMeters_);
    }
    unknownFields.writeTo(output);
  }

  @java.lang.Override
  public int getSerializedSize() {
    int size = memoizedSize;
    if (size != -1) return size;

    size = 0;
    if (((bitField0_ & 0x00000001) != 0)) {
      size += com.google.protobuf.CodedOutputStream
        .computeUInt64Size(1, durationMs_);
    }
    if (((bitField0_ & 0x00000002) != 0)) {
      size += com.google.protobuf.CodedOutputStream
        .computeUInt32Size(2, minSensorDelayMs_);
    }
    if (((bitField0_ & 0x00000004) != 0)) {
      size += com.google.protobuf.CodedOutputStream
        .computeUInt32Size(3, tapCount_);
    }
    if (((bitField0_ & 0x00000008) != 0)) {
      size += com.google.protobuf.CodedOutputStream
        .computeUInt32Size(4, orientationChangeCount_);
    }
    if (((bitField0_ & 0x00000010) != 0)) {
      size += com.google.protobuf.CodedOutputStream
        .computeBoolSize(5, virtualSensorsVisible_);
    }
    if (((bitField0_ & 0x00000020) != 0)) {
      size += com.google.protobuf.CodedOutputStream
        .computeUInt32Size(6, virtualSensorsInteractionCount_);
    }
    if (((bitField0_ & 0x00000040) != 0)) {
      size += com.google.protobuf.CodedOutputStream
        .computeUInt32Size(7, hotkeyInvokeCount_);
    }
    if (((bitField0_ & 0x00000080) != 0)) {
      size += com.google.protobuf.CodedOutputStream
        .computeUInt64Size(8, hotkeyDurationMs_);
    }
    if (((bitField0_ & 0x00000100) != 0)) {
      size += com.google.protobuf.CodedOutputStream
        .computeUInt32Size(9, tapsAfterHotkeyInvoke_);
    }
    if (((bitField0_ & 0x00000200) != 0)) {
      size += com.google.protobuf.CodedOutputStream
        .computeDoubleSize(10, totalRotationRadians_);
    }
    if (((bitField0_ & 0x00000400) != 0)) {
      size += com.google.protobuf.CodedOutputStream
        .computeDoubleSize(11, totalTranslationMeters_);
    }
    size += unknownFields.getSerializedSize();
    memoizedSize = size;
    return size;
  }

  @java.lang.Override
  public boolean equals(final java.lang.Object obj) {
    if (obj == this) {
     return true;
    }
    if (!(obj instanceof com.google.wireless.android.sdk.stats.EmulatorVirtualSceneSession)) {
      return super.equals(obj);
    }
    com.google.wireless.android.sdk.stats.EmulatorVirtualSceneSession other = (com.google.wireless.android.sdk.stats.EmulatorVirtualSceneSession) obj;

    if (hasDurationMs() != other.hasDurationMs()) return false;
    if (hasDurationMs()) {
      if (getDurationMs()
          != other.getDurationMs()) return false;
    }
    if (hasMinSensorDelayMs() != other.hasMinSensorDelayMs()) return false;
    if (hasMinSensorDelayMs()) {
      if (getMinSensorDelayMs()
          != other.getMinSensorDelayMs()) return false;
    }
    if (hasTapCount() != other.hasTapCount()) return false;
    if (hasTapCount()) {
      if (getTapCount()
          != other.getTapCount()) return false;
    }
    if (hasOrientationChangeCount() != other.hasOrientationChangeCount()) return false;
    if (hasOrientationChangeCount()) {
      if (getOrientationChangeCount()
          != other.getOrientationChangeCount()) return false;
    }
    if (hasVirtualSensorsVisible() != other.hasVirtualSensorsVisible()) return false;
    if (hasVirtualSensorsVisible()) {
      if (getVirtualSensorsVisible()
          != other.getVirtualSensorsVisible()) return false;
    }
    if (hasVirtualSensorsInteractionCount() != other.hasVirtualSensorsInteractionCount()) return false;
    if (hasVirtualSensorsInteractionCount()) {
      if (getVirtualSensorsInteractionCount()
          != other.getVirtualSensorsInteractionCount()) return false;
    }
    if (hasHotkeyInvokeCount() != other.hasHotkeyInvokeCount()) return false;
    if (hasHotkeyInvokeCount()) {
      if (getHotkeyInvokeCount()
          != other.getHotkeyInvokeCount()) return false;
    }
    if (hasHotkeyDurationMs() != other.hasHotkeyDurationMs()) return false;
    if (hasHotkeyDurationMs()) {
      if (getHotkeyDurationMs()
          != other.getHotkeyDurationMs()) return false;
    }
    if (hasTapsAfterHotkeyInvoke() != other.hasTapsAfterHotkeyInvoke()) return false;
    if (hasTapsAfterHotkeyInvoke()) {
      if (getTapsAfterHotkeyInvoke()
          != other.getTapsAfterHotkeyInvoke()) return false;
    }
    if (hasTotalRotationRadians() != other.hasTotalRotationRadians()) return false;
    if (hasTotalRotationRadians()) {
      if (java.lang.Double.doubleToLongBits(getTotalRotationRadians())
          != java.lang.Double.doubleToLongBits(
              other.getTotalRotationRadians())) return false;
    }
    if (hasTotalTranslationMeters() != other.hasTotalTranslationMeters()) return false;
    if (hasTotalTranslationMeters()) {
      if (java.lang.Double.doubleToLongBits(getTotalTranslationMeters())
          != java.lang.Double.doubleToLongBits(
              other.getTotalTranslationMeters())) return false;
    }
    if (!unknownFields.equals(other.unknownFields)) return false;
    return true;
  }

  @java.lang.Override
  public int hashCode() {
    if (memoizedHashCode != 0) {
      return memoizedHashCode;
    }
    int hash = 41;
    hash = (19 * hash) + getDescriptor().hashCode();
    if (hasDurationMs()) {
      hash = (37 * hash) + DURATION_MS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getDurationMs());
    }
    if (hasMinSensorDelayMs()) {
      hash = (37 * hash) + MIN_SENSOR_DELAY_MS_FIELD_NUMBER;
      hash = (53 * hash) + getMinSensorDelayMs();
    }
    if (hasTapCount()) {
      hash = (37 * hash) + TAP_COUNT_FIELD_NUMBER;
      hash = (53 * hash) + getTapCount();
    }
    if (hasOrientationChangeCount()) {
      hash = (37 * hash) + ORIENTATION_CHANGE_COUNT_FIELD_NUMBER;
      hash = (53 * hash) + getOrientationChangeCount();
    }
    if (hasVirtualSensorsVisible()) {
      hash = (37 * hash) + VIRTUAL_SENSORS_VISIBLE_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(
          getVirtualSensorsVisible());
    }
    if (hasVirtualSensorsInteractionCount()) {
      hash = (37 * hash) + VIRTUAL_SENSORS_INTERACTION_COUNT_FIELD_NUMBER;
      hash = (53 * hash) + getVirtualSensorsInteractionCount();
    }
    if (hasHotkeyInvokeCount()) {
      hash = (37 * hash) + HOTKEY_INVOKE_COUNT_FIELD_NUMBER;
      hash = (53 * hash) + getHotkeyInvokeCount();
    }
    if (hasHotkeyDurationMs()) {
      hash = (37 * hash) + HOTKEY_DURATION_MS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          getHotkeyDurationMs());
    }
    if (hasTapsAfterHotkeyInvoke()) {
      hash = (37 * hash) + TAPS_AFTER_HOTKEY_INVOKE_FIELD_NUMBER;
      hash = (53 * hash) + getTapsAfterHotkeyInvoke();
    }
    if (hasTotalRotationRadians()) {
      hash = (37 * hash) + TOTAL_ROTATION_RADIANS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          java.lang.Double.doubleToLongBits(getTotalRotationRadians()));
    }
    if (hasTotalTranslationMeters()) {
      hash = (37 * hash) + TOTAL_TRANSLATION_METERS_FIELD_NUMBER;
      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(
          java.lang.Double.doubleToLongBits(getTotalTranslationMeters()));
    }
    hash = (29 * hash) + unknownFields.hashCode();
    memoizedHashCode = hash;
    return hash;
  }

  public static com.google.wireless.android.sdk.stats.EmulatorVirtualSceneSession parseFrom(
      java.nio.ByteBuffer data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static com.google.wireless.android.sdk.stats.EmulatorVirtualSceneSession parseFrom(
      java.nio.ByteBuffer data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static com.google.wireless.android.sdk.stats.EmulatorVirtualSceneSession parseFrom(
      com.google.protobuf.ByteString data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static com.google.wireless.android.sdk.stats.EmulatorVirtualSceneSession parseFrom(
      com.google.protobuf.ByteString data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static com.google.wireless.android.sdk.stats.EmulatorVirtualSceneSession parseFrom(byte[] data)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data);
  }
  public static com.google.wireless.android.sdk.stats.EmulatorVirtualSceneSession parseFrom(
      byte[] data,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws com.google.protobuf.InvalidProtocolBufferException {
    return PARSER.parseFrom(data, extensionRegistry);
  }
  public static com.google.wireless.android.sdk.stats.EmulatorVirtualSceneSession parseFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input);
  }
  public static com.google.wireless.android.sdk.stats.EmulatorVirtualSceneSession parseFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input, extensionRegistry);
  }
  public static com.google.wireless.android.sdk.stats.EmulatorVirtualSceneSession parseDelimitedFrom(java.io.InputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseDelimitedWithIOException(PARSER, input);
  }
  public static com.google.wireless.android.sdk.stats.EmulatorVirtualSceneSession parseDelimitedFrom(
      java.io.InputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseDelimitedWithIOException(PARSER, input, extensionRegistry);
  }
  public static com.google.wireless.android.sdk.stats.EmulatorVirtualSceneSession parseFrom(
      com.google.protobuf.CodedInputStream input)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input);
  }
  public static com.google.wireless.android.sdk.stats.EmulatorVirtualSceneSession parseFrom(
      com.google.protobuf.CodedInputStream input,
      com.google.protobuf.ExtensionRegistryLite extensionRegistry)
      throws java.io.IOException {
    return com.google.protobuf.GeneratedMessageV3
        .parseWithIOException(PARSER, input, extensionRegistry);
  }

  @java.lang.Override
  public Builder newBuilderForType() { return newBuilder(); }
  public static Builder newBuilder() {
    return DEFAULT_INSTANCE.toBuilder();
  }
  public static Builder newBuilder(com.google.wireless.android.sdk.stats.EmulatorVirtualSceneSession prototype) {
    return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);
  }
  @java.lang.Override
  public Builder toBuilder() {
    return this == DEFAULT_INSTANCE
        ? new Builder() : new Builder().mergeFrom(this);
  }

  @java.lang.Override
  protected Builder newBuilderForType(
      com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
    Builder builder = new Builder(parent);
    return builder;
  }
  /**
   * <pre>
   * Metrics for virtual scene camera sessions.
   * </pre>
   *
   * Protobuf type {@code android_studio.EmulatorVirtualSceneSession}
   */
  public static final class Builder extends
      com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements
      // @@protoc_insertion_point(builder_implements:android_studio.EmulatorVirtualSceneSession)
      com.google.wireless.android.sdk.stats.EmulatorVirtualSceneSessionOrBuilder {
    public static final com.google.protobuf.Descriptors.Descriptor
        getDescriptor() {
      return com.google.wireless.android.sdk.stats.AndroidStudioStats.internal_static_android_studio_EmulatorVirtualSceneSession_descriptor;
    }

    @java.lang.Override
    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable
        internalGetFieldAccessorTable() {
      return com.google.wireless.android.sdk.stats.AndroidStudioStats.internal_static_android_studio_EmulatorVirtualSceneSession_fieldAccessorTable
          .ensureFieldAccessorsInitialized(
              com.google.wireless.android.sdk.stats.EmulatorVirtualSceneSession.class, com.google.wireless.android.sdk.stats.EmulatorVirtualSceneSession.Builder.class);
    }

    // Construct using com.google.wireless.android.sdk.stats.EmulatorVirtualSceneSession.newBuilder()
    private Builder() {
      maybeForceBuilderInitialization();
    }

    private Builder(
        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {
      super(parent);
      maybeForceBuilderInitialization();
    }
    private void maybeForceBuilderInitialization() {
      if (com.google.protobuf.GeneratedMessageV3
              .alwaysUseFieldBuilders) {
      }
    }
    @java.lang.Override
    public Builder clear() {
      super.clear();
      durationMs_ = 0L;
      bitField0_ = (bitField0_ & ~0x00000001);
      minSensorDelayMs_ = 0;
      bitField0_ = (bitField0_ & ~0x00000002);
      tapCount_ = 0;
      bitField0_ = (bitField0_ & ~0x00000004);
      orientationChangeCount_ = 0;
      bitField0_ = (bitField0_ & ~0x00000008);
      virtualSensorsVisible_ = false;
      bitField0_ = (bitField0_ & ~0x00000010);
      virtualSensorsInteractionCount_ = 0;
      bitField0_ = (bitField0_ & ~0x00000020);
      hotkeyInvokeCount_ = 0;
      bitField0_ = (bitField0_ & ~0x00000040);
      hotkeyDurationMs_ = 0L;
      bitField0_ = (bitField0_ & ~0x00000080);
      tapsAfterHotkeyInvoke_ = 0;
      bitField0_ = (bitField0_ & ~0x00000100);
      totalRotationRadians_ = 0D;
      bitField0_ = (bitField0_ & ~0x00000200);
      totalTranslationMeters_ = 0D;
      bitField0_ = (bitField0_ & ~0x00000400);
      return this;
    }

    @java.lang.Override
    public com.google.protobuf.Descriptors.Descriptor
        getDescriptorForType() {
      return com.google.wireless.android.sdk.stats.AndroidStudioStats.internal_static_android_studio_EmulatorVirtualSceneSession_descriptor;
    }

    @java.lang.Override
    public com.google.wireless.android.sdk.stats.EmulatorVirtualSceneSession getDefaultInstanceForType() {
      return com.google.wireless.android.sdk.stats.EmulatorVirtualSceneSession.getDefaultInstance();
    }

    @java.lang.Override
    public com.google.wireless.android.sdk.stats.EmulatorVirtualSceneSession build() {
      com.google.wireless.android.sdk.stats.EmulatorVirtualSceneSession result = buildPartial();
      if (!result.isInitialized()) {
        throw newUninitializedMessageException(result);
      }
      return result;
    }

    @java.lang.Override
    public com.google.wireless.android.sdk.stats.EmulatorVirtualSceneSession buildPartial() {
      com.google.wireless.android.sdk.stats.EmulatorVirtualSceneSession result = new com.google.wireless.android.sdk.stats.EmulatorVirtualSceneSession(this);
      int from_bitField0_ = bitField0_;
      int to_bitField0_ = 0;
      if (((from_bitField0_ & 0x00000001) != 0)) {
        result.durationMs_ = durationMs_;
        to_bitField0_ |= 0x00000001;
      }
      if (((from_bitField0_ & 0x00000002) != 0)) {
        result.minSensorDelayMs_ = minSensorDelayMs_;
        to_bitField0_ |= 0x00000002;
      }
      if (((from_bitField0_ & 0x00000004) != 0)) {
        result.tapCount_ = tapCount_;
        to_bitField0_ |= 0x00000004;
      }
      if (((from_bitField0_ & 0x00000008) != 0)) {
        result.orientationChangeCount_ = orientationChangeCount_;
        to_bitField0_ |= 0x00000008;
      }
      if (((from_bitField0_ & 0x00000010) != 0)) {
        result.virtualSensorsVisible_ = virtualSensorsVisible_;
        to_bitField0_ |= 0x00000010;
      }
      if (((from_bitField0_ & 0x00000020) != 0)) {
        result.virtualSensorsInteractionCount_ = virtualSensorsInteractionCount_;
        to_bitField0_ |= 0x00000020;
      }
      if (((from_bitField0_ & 0x00000040) != 0)) {
        result.hotkeyInvokeCount_ = hotkeyInvokeCount_;
        to_bitField0_ |= 0x00000040;
      }
      if (((from_bitField0_ & 0x00000080) != 0)) {
        result.hotkeyDurationMs_ = hotkeyDurationMs_;
        to_bitField0_ |= 0x00000080;
      }
      if (((from_bitField0_ & 0x00000100) != 0)) {
        result.tapsAfterHotkeyInvoke_ = tapsAfterHotkeyInvoke_;
        to_bitField0_ |= 0x00000100;
      }
      if (((from_bitField0_ & 0x00000200) != 0)) {
        result.totalRotationRadians_ = totalRotationRadians_;
        to_bitField0_ |= 0x00000200;
      }
      if (((from_bitField0_ & 0x00000400) != 0)) {
        result.totalTranslationMeters_ = totalTranslationMeters_;
        to_bitField0_ |= 0x00000400;
      }
      result.bitField0_ = to_bitField0_;
      onBuilt();
      return result;
    }

    @java.lang.Override
    public Builder clone() {
      return super.clone();
    }
    @java.lang.Override
    public Builder setField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        java.lang.Object value) {
      return super.setField(field, value);
    }
    @java.lang.Override
    public Builder clearField(
        com.google.protobuf.Descriptors.FieldDescriptor field) {
      return super.clearField(field);
    }
    @java.lang.Override
    public Builder clearOneof(
        com.google.protobuf.Descriptors.OneofDescriptor oneof) {
      return super.clearOneof(oneof);
    }
    @java.lang.Override
    public Builder setRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        int index, java.lang.Object value) {
      return super.setRepeatedField(field, index, value);
    }
    @java.lang.Override
    public Builder addRepeatedField(
        com.google.protobuf.Descriptors.FieldDescriptor field,
        java.lang.Object value) {
      return super.addRepeatedField(field, value);
    }
    @java.lang.Override
    public Builder mergeFrom(com.google.protobuf.Message other) {
      if (other instanceof com.google.wireless.android.sdk.stats.EmulatorVirtualSceneSession) {
        return mergeFrom((com.google.wireless.android.sdk.stats.EmulatorVirtualSceneSession)other);
      } else {
        super.mergeFrom(other);
        return this;
      }
    }

    public Builder mergeFrom(com.google.wireless.android.sdk.stats.EmulatorVirtualSceneSession other) {
      if (other == com.google.wireless.android.sdk.stats.EmulatorVirtualSceneSession.getDefaultInstance()) return this;
      if (other.hasDurationMs()) {
        setDurationMs(other.getDurationMs());
      }
      if (other.hasMinSensorDelayMs()) {
        setMinSensorDelayMs(other.getMinSensorDelayMs());
      }
      if (other.hasTapCount()) {
        setTapCount(other.getTapCount());
      }
      if (other.hasOrientationChangeCount()) {
        setOrientationChangeCount(other.getOrientationChangeCount());
      }
      if (other.hasVirtualSensorsVisible()) {
        setVirtualSensorsVisible(other.getVirtualSensorsVisible());
      }
      if (other.hasVirtualSensorsInteractionCount()) {
        setVirtualSensorsInteractionCount(other.getVirtualSensorsInteractionCount());
      }
      if (other.hasHotkeyInvokeCount()) {
        setHotkeyInvokeCount(other.getHotkeyInvokeCount());
      }
      if (other.hasHotkeyDurationMs()) {
        setHotkeyDurationMs(other.getHotkeyDurationMs());
      }
      if (other.hasTapsAfterHotkeyInvoke()) {
        setTapsAfterHotkeyInvoke(other.getTapsAfterHotkeyInvoke());
      }
      if (other.hasTotalRotationRadians()) {
        setTotalRotationRadians(other.getTotalRotationRadians());
      }
      if (other.hasTotalTranslationMeters()) {
        setTotalTranslationMeters(other.getTotalTranslationMeters());
      }
      this.mergeUnknownFields(other.unknownFields);
      onChanged();
      return this;
    }

    @java.lang.Override
    public final boolean isInitialized() {
      return true;
    }

    @java.lang.Override
    public Builder mergeFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws java.io.IOException {
      com.google.wireless.android.sdk.stats.EmulatorVirtualSceneSession parsedMessage = null;
      try {
        parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);
      } catch (com.google.protobuf.InvalidProtocolBufferException e) {
        parsedMessage = (com.google.wireless.android.sdk.stats.EmulatorVirtualSceneSession) e.getUnfinishedMessage();
        throw e.unwrapIOException();
      } finally {
        if (parsedMessage != null) {
          mergeFrom(parsedMessage);
        }
      }
      return this;
    }
    private int bitField0_;

    private long durationMs_ ;
    /**
     * <pre>
     * How long the session was running, in milliseconds.
     * </pre>
     *
     * <code>optional uint64 duration_ms = 1;</code>
     * @return Whether the durationMs field is set.
     */
    public boolean hasDurationMs() {
      return ((bitField0_ & 0x00000001) != 0);
    }
    /**
     * <pre>
     * How long the session was running, in milliseconds.
     * </pre>
     *
     * <code>optional uint64 duration_ms = 1;</code>
     * @return The durationMs.
     */
    public long getDurationMs() {
      return durationMs_;
    }
    /**
     * <pre>
     * How long the session was running, in milliseconds.
     * </pre>
     *
     * <code>optional uint64 duration_ms = 1;</code>
     * @param value The durationMs to set.
     * @return This builder for chaining.
     */
    public Builder setDurationMs(long value) {
      bitField0_ |= 0x00000001;
      durationMs_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * How long the session was running, in milliseconds.
     * </pre>
     *
     * <code>optional uint64 duration_ms = 1;</code>
     * @return This builder for chaining.
     */
    public Builder clearDurationMs() {
      bitField0_ = (bitField0_ & ~0x00000001);
      durationMs_ = 0L;
      onChanged();
      return this;
    }

    private int minSensorDelayMs_ ;
    /**
     * <pre>
     * Minimum sensor update delay in milliseconds.
     * </pre>
     *
     * <code>optional uint32 min_sensor_delay_ms = 2;</code>
     * @return Whether the minSensorDelayMs field is set.
     */
    public boolean hasMinSensorDelayMs() {
      return ((bitField0_ & 0x00000002) != 0);
    }
    /**
     * <pre>
     * Minimum sensor update delay in milliseconds.
     * </pre>
     *
     * <code>optional uint32 min_sensor_delay_ms = 2;</code>
     * @return The minSensorDelayMs.
     */
    public int getMinSensorDelayMs() {
      return minSensorDelayMs_;
    }
    /**
     * <pre>
     * Minimum sensor update delay in milliseconds.
     * </pre>
     *
     * <code>optional uint32 min_sensor_delay_ms = 2;</code>
     * @param value The minSensorDelayMs to set.
     * @return This builder for chaining.
     */
    public Builder setMinSensorDelayMs(int value) {
      bitField0_ |= 0x00000002;
      minSensorDelayMs_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Minimum sensor update delay in milliseconds.
     * </pre>
     *
     * <code>optional uint32 min_sensor_delay_ms = 2;</code>
     * @return This builder for chaining.
     */
    public Builder clearMinSensorDelayMs() {
      bitField0_ = (bitField0_ & ~0x00000002);
      minSensorDelayMs_ = 0;
      onChanged();
      return this;
    }

    private int tapCount_ ;
    /**
     * <pre>
     * Total tap count when the camera is running.
     * </pre>
     *
     * <code>optional uint32 tap_count = 3;</code>
     * @return Whether the tapCount field is set.
     */
    public boolean hasTapCount() {
      return ((bitField0_ & 0x00000004) != 0);
    }
    /**
     * <pre>
     * Total tap count when the camera is running.
     * </pre>
     *
     * <code>optional uint32 tap_count = 3;</code>
     * @return The tapCount.
     */
    public int getTapCount() {
      return tapCount_;
    }
    /**
     * <pre>
     * Total tap count when the camera is running.
     * </pre>
     *
     * <code>optional uint32 tap_count = 3;</code>
     * @param value The tapCount to set.
     * @return This builder for chaining.
     */
    public Builder setTapCount(int value) {
      bitField0_ |= 0x00000004;
      tapCount_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Total tap count when the camera is running.
     * </pre>
     *
     * <code>optional uint32 tap_count = 3;</code>
     * @return This builder for chaining.
     */
    public Builder clearTapCount() {
      bitField0_ = (bitField0_ & ~0x00000004);
      tapCount_ = 0;
      onChanged();
      return this;
    }

    private int orientationChangeCount_ ;
    /**
     * <pre>
     * The number of times the orientation changed during the session.
     * </pre>
     *
     * <code>optional uint32 orientation_change_count = 4;</code>
     * @return Whether the orientationChangeCount field is set.
     */
    public boolean hasOrientationChangeCount() {
      return ((bitField0_ & 0x00000008) != 0);
    }
    /**
     * <pre>
     * The number of times the orientation changed during the session.
     * </pre>
     *
     * <code>optional uint32 orientation_change_count = 4;</code>
     * @return The orientationChangeCount.
     */
    public int getOrientationChangeCount() {
      return orientationChangeCount_;
    }
    /**
     * <pre>
     * The number of times the orientation changed during the session.
     * </pre>
     *
     * <code>optional uint32 orientation_change_count = 4;</code>
     * @param value The orientationChangeCount to set.
     * @return This builder for chaining.
     */
    public Builder setOrientationChangeCount(int value) {
      bitField0_ |= 0x00000008;
      orientationChangeCount_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * The number of times the orientation changed during the session.
     * </pre>
     *
     * <code>optional uint32 orientation_change_count = 4;</code>
     * @return This builder for chaining.
     */
    public Builder clearOrientationChangeCount() {
      bitField0_ = (bitField0_ & ~0x00000008);
      orientationChangeCount_ = 0;
      onChanged();
      return this;
    }

    private boolean virtualSensorsVisible_ ;
    /**
     * <pre>
     * Whether the virtual sensors window was visible at any point during the
     * session.
     * </pre>
     *
     * <code>optional bool virtual_sensors_visible = 5;</code>
     * @return Whether the virtualSensorsVisible field is set.
     */
    public boolean hasVirtualSensorsVisible() {
      return ((bitField0_ & 0x00000010) != 0);
    }
    /**
     * <pre>
     * Whether the virtual sensors window was visible at any point during the
     * session.
     * </pre>
     *
     * <code>optional bool virtual_sensors_visible = 5;</code>
     * @return The virtualSensorsVisible.
     */
    public boolean getVirtualSensorsVisible() {
      return virtualSensorsVisible_;
    }
    /**
     * <pre>
     * Whether the virtual sensors window was visible at any point during the
     * session.
     * </pre>
     *
     * <code>optional bool virtual_sensors_visible = 5;</code>
     * @param value The virtualSensorsVisible to set.
     * @return This builder for chaining.
     */
    public Builder setVirtualSensorsVisible(boolean value) {
      bitField0_ |= 0x00000010;
      virtualSensorsVisible_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Whether the virtual sensors window was visible at any point during the
     * session.
     * </pre>
     *
     * <code>optional bool virtual_sensors_visible = 5;</code>
     * @return This builder for chaining.
     */
    public Builder clearVirtualSensorsVisible() {
      bitField0_ = (bitField0_ & ~0x00000010);
      virtualSensorsVisible_ = false;
      onChanged();
      return this;
    }

    private int virtualSensorsInteractionCount_ ;
    /**
     * <pre>
     * How many interactions were performed on the virtual sensors page.
     * </pre>
     *
     * <code>optional uint32 virtual_sensors_interaction_count = 6;</code>
     * @return Whether the virtualSensorsInteractionCount field is set.
     */
    public boolean hasVirtualSensorsInteractionCount() {
      return ((bitField0_ & 0x00000020) != 0);
    }
    /**
     * <pre>
     * How many interactions were performed on the virtual sensors page.
     * </pre>
     *
     * <code>optional uint32 virtual_sensors_interaction_count = 6;</code>
     * @return The virtualSensorsInteractionCount.
     */
    public int getVirtualSensorsInteractionCount() {
      return virtualSensorsInteractionCount_;
    }
    /**
     * <pre>
     * How many interactions were performed on the virtual sensors page.
     * </pre>
     *
     * <code>optional uint32 virtual_sensors_interaction_count = 6;</code>
     * @param value The virtualSensorsInteractionCount to set.
     * @return This builder for chaining.
     */
    public Builder setVirtualSensorsInteractionCount(int value) {
      bitField0_ |= 0x00000020;
      virtualSensorsInteractionCount_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * How many interactions were performed on the virtual sensors page.
     * </pre>
     *
     * <code>optional uint32 virtual_sensors_interaction_count = 6;</code>
     * @return This builder for chaining.
     */
    public Builder clearVirtualSensorsInteractionCount() {
      bitField0_ = (bitField0_ & ~0x00000020);
      virtualSensorsInteractionCount_ = 0;
      onChanged();
      return this;
    }

    private int hotkeyInvokeCount_ ;
    /**
     * <pre>
     * Invocation count of WASD/Mouselook hotkey.
     * </pre>
     *
     * <code>optional uint32 hotkey_invoke_count = 7;</code>
     * @return Whether the hotkeyInvokeCount field is set.
     */
    public boolean hasHotkeyInvokeCount() {
      return ((bitField0_ & 0x00000040) != 0);
    }
    /**
     * <pre>
     * Invocation count of WASD/Mouselook hotkey.
     * </pre>
     *
     * <code>optional uint32 hotkey_invoke_count = 7;</code>
     * @return The hotkeyInvokeCount.
     */
    public int getHotkeyInvokeCount() {
      return hotkeyInvokeCount_;
    }
    /**
     * <pre>
     * Invocation count of WASD/Mouselook hotkey.
     * </pre>
     *
     * <code>optional uint32 hotkey_invoke_count = 7;</code>
     * @param value The hotkeyInvokeCount to set.
     * @return This builder for chaining.
     */
    public Builder setHotkeyInvokeCount(int value) {
      bitField0_ |= 0x00000040;
      hotkeyInvokeCount_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Invocation count of WASD/Mouselook hotkey.
     * </pre>
     *
     * <code>optional uint32 hotkey_invoke_count = 7;</code>
     * @return This builder for chaining.
     */
    public Builder clearHotkeyInvokeCount() {
      bitField0_ = (bitField0_ & ~0x00000040);
      hotkeyInvokeCount_ = 0;
      onChanged();
      return this;
    }

    private long hotkeyDurationMs_ ;
    /**
     * <pre>
     * Total time the user was in WASD/Mouselook mode during this session.
     * </pre>
     *
     * <code>optional uint64 hotkey_duration_ms = 8;</code>
     * @return Whether the hotkeyDurationMs field is set.
     */
    public boolean hasHotkeyDurationMs() {
      return ((bitField0_ & 0x00000080) != 0);
    }
    /**
     * <pre>
     * Total time the user was in WASD/Mouselook mode during this session.
     * </pre>
     *
     * <code>optional uint64 hotkey_duration_ms = 8;</code>
     * @return The hotkeyDurationMs.
     */
    public long getHotkeyDurationMs() {
      return hotkeyDurationMs_;
    }
    /**
     * <pre>
     * Total time the user was in WASD/Mouselook mode during this session.
     * </pre>
     *
     * <code>optional uint64 hotkey_duration_ms = 8;</code>
     * @param value The hotkeyDurationMs to set.
     * @return This builder for chaining.
     */
    public Builder setHotkeyDurationMs(long value) {
      bitField0_ |= 0x00000080;
      hotkeyDurationMs_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Total time the user was in WASD/Mouselook mode during this session.
     * </pre>
     *
     * <code>optional uint64 hotkey_duration_ms = 8;</code>
     * @return This builder for chaining.
     */
    public Builder clearHotkeyDurationMs() {
      bitField0_ = (bitField0_ & ~0x00000080);
      hotkeyDurationMs_ = 0L;
      onChanged();
      return this;
    }

    private int tapsAfterHotkeyInvoke_ ;
    /**
     * <pre>
     * Taps shortly after a hotkey invoke, to determine how much the user
     * alternates between modes to tap.
     * </pre>
     *
     * <code>optional uint32 taps_after_hotkey_invoke = 9;</code>
     * @return Whether the tapsAfterHotkeyInvoke field is set.
     */
    public boolean hasTapsAfterHotkeyInvoke() {
      return ((bitField0_ & 0x00000100) != 0);
    }
    /**
     * <pre>
     * Taps shortly after a hotkey invoke, to determine how much the user
     * alternates between modes to tap.
     * </pre>
     *
     * <code>optional uint32 taps_after_hotkey_invoke = 9;</code>
     * @return The tapsAfterHotkeyInvoke.
     */
    public int getTapsAfterHotkeyInvoke() {
      return tapsAfterHotkeyInvoke_;
    }
    /**
     * <pre>
     * Taps shortly after a hotkey invoke, to determine how much the user
     * alternates between modes to tap.
     * </pre>
     *
     * <code>optional uint32 taps_after_hotkey_invoke = 9;</code>
     * @param value The tapsAfterHotkeyInvoke to set.
     * @return This builder for chaining.
     */
    public Builder setTapsAfterHotkeyInvoke(int value) {
      bitField0_ |= 0x00000100;
      tapsAfterHotkeyInvoke_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Taps shortly after a hotkey invoke, to determine how much the user
     * alternates between modes to tap.
     * </pre>
     *
     * <code>optional uint32 taps_after_hotkey_invoke = 9;</code>
     * @return This builder for chaining.
     */
    public Builder clearTapsAfterHotkeyInvoke() {
      bitField0_ = (bitField0_ & ~0x00000100);
      tapsAfterHotkeyInvoke_ = 0;
      onChanged();
      return this;
    }

    private double totalRotationRadians_ ;
    /**
     * <pre>
     * Total rotation performed in the virtual scene.
     * </pre>
     *
     * <code>optional double total_rotation_radians = 10;</code>
     * @return Whether the totalRotationRadians field is set.
     */
    public boolean hasTotalRotationRadians() {
      return ((bitField0_ & 0x00000200) != 0);
    }
    /**
     * <pre>
     * Total rotation performed in the virtual scene.
     * </pre>
     *
     * <code>optional double total_rotation_radians = 10;</code>
     * @return The totalRotationRadians.
     */
    public double getTotalRotationRadians() {
      return totalRotationRadians_;
    }
    /**
     * <pre>
     * Total rotation performed in the virtual scene.
     * </pre>
     *
     * <code>optional double total_rotation_radians = 10;</code>
     * @param value The totalRotationRadians to set.
     * @return This builder for chaining.
     */
    public Builder setTotalRotationRadians(double value) {
      bitField0_ |= 0x00000200;
      totalRotationRadians_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Total rotation performed in the virtual scene.
     * </pre>
     *
     * <code>optional double total_rotation_radians = 10;</code>
     * @return This builder for chaining.
     */
    public Builder clearTotalRotationRadians() {
      bitField0_ = (bitField0_ & ~0x00000200);
      totalRotationRadians_ = 0D;
      onChanged();
      return this;
    }

    private double totalTranslationMeters_ ;
    /**
     * <pre>
     * Total translation performed in the virtual scene.
     * </pre>
     *
     * <code>optional double total_translation_meters = 11;</code>
     * @return Whether the totalTranslationMeters field is set.
     */
    public boolean hasTotalTranslationMeters() {
      return ((bitField0_ & 0x00000400) != 0);
    }
    /**
     * <pre>
     * Total translation performed in the virtual scene.
     * </pre>
     *
     * <code>optional double total_translation_meters = 11;</code>
     * @return The totalTranslationMeters.
     */
    public double getTotalTranslationMeters() {
      return totalTranslationMeters_;
    }
    /**
     * <pre>
     * Total translation performed in the virtual scene.
     * </pre>
     *
     * <code>optional double total_translation_meters = 11;</code>
     * @param value The totalTranslationMeters to set.
     * @return This builder for chaining.
     */
    public Builder setTotalTranslationMeters(double value) {
      bitField0_ |= 0x00000400;
      totalTranslationMeters_ = value;
      onChanged();
      return this;
    }
    /**
     * <pre>
     * Total translation performed in the virtual scene.
     * </pre>
     *
     * <code>optional double total_translation_meters = 11;</code>
     * @return This builder for chaining.
     */
    public Builder clearTotalTranslationMeters() {
      bitField0_ = (bitField0_ & ~0x00000400);
      totalTranslationMeters_ = 0D;
      onChanged();
      return this;
    }
    @java.lang.Override
    public final Builder setUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.setUnknownFields(unknownFields);
    }

    @java.lang.Override
    public final Builder mergeUnknownFields(
        final com.google.protobuf.UnknownFieldSet unknownFields) {
      return super.mergeUnknownFields(unknownFields);
    }


    // @@protoc_insertion_point(builder_scope:android_studio.EmulatorVirtualSceneSession)
  }

  // @@protoc_insertion_point(class_scope:android_studio.EmulatorVirtualSceneSession)
  private static final com.google.wireless.android.sdk.stats.EmulatorVirtualSceneSession DEFAULT_INSTANCE;
  static {
    DEFAULT_INSTANCE = new com.google.wireless.android.sdk.stats.EmulatorVirtualSceneSession();
  }

  public static com.google.wireless.android.sdk.stats.EmulatorVirtualSceneSession getDefaultInstance() {
    return DEFAULT_INSTANCE;
  }

  @java.lang.Deprecated public static final com.google.protobuf.Parser<EmulatorVirtualSceneSession>
      PARSER = new com.google.protobuf.AbstractParser<EmulatorVirtualSceneSession>() {
    @java.lang.Override
    public EmulatorVirtualSceneSession parsePartialFrom(
        com.google.protobuf.CodedInputStream input,
        com.google.protobuf.ExtensionRegistryLite extensionRegistry)
        throws com.google.protobuf.InvalidProtocolBufferException {
      return new EmulatorVirtualSceneSession(input, extensionRegistry);
    }
  };

  public static com.google.protobuf.Parser<EmulatorVirtualSceneSession> parser() {
    return PARSER;
  }

  @java.lang.Override
  public com.google.protobuf.Parser<EmulatorVirtualSceneSession> getParserForType() {
    return PARSER;
  }

  @java.lang.Override
  public com.google.wireless.android.sdk.stats.EmulatorVirtualSceneSession getDefaultInstanceForType() {
    return DEFAULT_INSTANCE;
  }

}

